Bane is a test harness used to test your application's interaction with other servers.  It is based upon the material from Michael Nygard's "Release It!" book as described in the "Test Harness" chapter.

Bane is designed with three usage scenarios in mind:

1. Quick Start with a specific behavior from the command line.  If your application talks to another server on a given port, you can start bane from the command line by specifying the desired port and a name of server behavior.  For example, if your server talks to a third-party server on port 8080, you could start the "Never Respond" behavior on port 8080 to observe how your application behaves.

Example:  $ bin/bane 8080 NeverRespond

2. Quick Start with a variety of behaviors from the command line.  If you just want a general purpose test harness to run, and you can easily control the ports that your application talks to, you can start bane up with a base port number and it will start all its known behaviors.  This way you can leave bane running and tweak your application to talk to each of the various behaviors.

Example: $ bin/bane 3000

3. Advanced Configuration using Ruby.  [NOT YET IMPLEMENTED] If you want to modify some of the defaults used in the included behaviors, you can initialize Bane with a Hash of port numbers, behavior names, and configuration parameters.  For example, you might want to change the DelugeResponder to repond with one gigabyte instead of the default one hundred megabytes. 

Example: [TBD, see the sample.rb file for ideas]


---

Here is some information from "Release It!" which explains the motivations of bane. 

A list of possible test harness behaviors from "Release It!" p. 126 ("Test Harness"):

"... the socket connection is succeptible to the following failures:

* It can be refused.

* It can sit in a listen queue until the caller times out.

* The remote end can reply with a SYN/ACK and then never send any data.

* The remote end can send nothing but RESET packets.

* The remote end can report a full receive window and never drain the data.

* The connection can be established, but the remote end never sends a byte of data.

* The connection can be established, but packets could be lost causing retransmit delays

* The connection can be established, but the remote end never acknowledges receiving a packet, causing endless retransmits

* The service can accept a request, send response headers (supposing HTTP), and ndever send the response body.

* The service can send one byte of the response every thirty seconds.

* The service can send a response of HTML instead of the expected XML.

* The service can send megabytes when kilobytes are expected.

* The service can refuse all authentication credentials.

The failures fall into distinct categories: network transport problems, network protocol problems, application protocol problems, and application logic problems. ..."


Other behavior listed (p. 128):

"Many kinds of bad behavior will be similar for different applications and protocols.  For example, refusing connections, connecting slowly, and accepting requests without reply would apply to any socket protocol: HTTP, RMI, or RPC."

"... accept connections but never reply..."
"... gets a connection and a reply, but the reply is from /dev/random ..."
"... open a connection and then drop it immediately ..."


